// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSPrepareMain

#define CLOSEVALUE -0.01

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> gWorldPositionTexture;
RWTexture2D<float> resultShadowTexture;

float2 screenSize;

ByteAddressBuffer modelVertices;
ByteAddressBuffer modelIndices;

int vertexStride;
int indexCount;

Texture2D<float4> modelTexture;
float2 modelTextureSize;

float4x4 worldToObject;
float4x4 objecToWorld;

float3 objectCenter;
float3 objectBound;

float3 localLightDirection;
float3 globalLightDirection;

//RWStructuredBuffer<float4> debugBuffer;

struct MeshTriangleProperty {
    float3 normalRaw; 
    float normalArea;
    float3 normal;
    float normalLength;

    float3 pointA;
    float triangleCALength2;
    
    float3 pointB;
    float ln;

    float3 pointC;
    int isIgnore; // 1 : ignore 
};

RWStructuredBuffer<MeshTriangleProperty> meshTriangleBuffer;

void LoadVertexData(uint index, out float3 position, out float2 uv) {
    uint pi = index * vertexStride; // index * (3[position.xyz] + 2[uv.xy]) * 4[bytes]
    position = asfloat(modelVertices.Load3(pi + 0));
    uv = asfloat(modelVertices.Load2(pi + (3 * 4)));
}

#define INDEX_FORMAT_16

uint3 loadTriangleIndices(uint nTriangle)
{
#if defined(INDEX_FORMAT_16)
    // stolen from: https://github.com/microsoft/DirectX-Graphics-Samples/blob/master/Samples/Desktop/D3D12Raytracing/src/D3D12RaytracingSimpleLighting/Raytracing.hlsl
    uint offsetBytes = nTriangle * 2;
    uint dwordAlignedOffset = offsetBytes & ~3;
    uint2 four16BitIndices = modelIndices.Load2(dwordAlignedOffset);
    uint3 indices;
    if (dwordAlignedOffset == offsetBytes)
    {
        indices.x = four16BitIndices.x & 0xffff;
        indices.y = (four16BitIndices.x >> 16) & 0xffff;
        indices.z = four16BitIndices.y & 0xffff;
    }
    else
    {
        indices.x = (four16BitIndices.x >> 16) & 0xffff;
        indices.y = four16BitIndices.y & 0xffff;
        indices.z = (four16BitIndices.y >> 16) & 0xffff;
    }
    return indices;
#elif defined(INDEX_FORMAT_32)
    uint offsetBytes = nTriangle * 12;
    return modelIndices.Load3(offsetBytes);
#else
    #error "Must define INDEX_FORMAT_16 or INDEX_FORMAT_32"
#endif
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    if(id.x >= screenSize.x || id.y >= screenSize.y)
        return;
    
    resultShadowTexture[id.xy] = 0;
    
    float3 worldPosition = (gWorldPositionTexture[id.xy]).xyz;
    float3 pixelToCenter = worldPosition - objectCenter.xyz;
    
    float distanceToClosestPointObject = dot(pixelToCenter, globalLightDirection);
    float3 closetPointsToObject = worldPosition - (globalLightDirection * distanceToClosestPointObject);
    float3 closetPointToCenter = closetPointsToObject - objectCenter;

    if(abs(closetPointToCenter.x) > objectBound.x || abs(closetPointToCenter.y) > objectBound.y || abs(closetPointToCenter.z) > objectBound.z)
        return;
    
    
    float3 localPosition = mul(worldToObject, float4(worldPosition, 1)).xyz;
    

   for (int i = 0; i < indexCount; i++) {
       if(meshTriangleBuffer[i].isIgnore == 1)
           continue;
           
       // Load vertex data
       float3 pointA = meshTriangleBuffer[i].pointA;
       float3 pointB = meshTriangleBuffer[i].pointB;
       float3 pointC = meshTriangleBuffer[i].pointC;
     
       float3 vec = localPosition - pointA;
       
       // if direction to closest point is opposite to received's surface normal 
       // or too close to receiver's point (consider as same point)
       // then ignore
       float dotVN = dot(vec, meshTriangleBuffer[i].normal);
       float ln = meshTriangleBuffer[i].ln;
       float t = (dotVN) / ln;
       //float t = (dotVN) / dot(-localLightDirection, normal);
       if (t > CLOSEVALUE)
           continue;

       // progject receiver's point(pixel) to caster's surface
        float3 snapLocalPosition = localPosition + (localLightDirection * t);

        float3 center = (pointA + pointB + pointC) / 3;
        float3 snapLocalPositionToCenter = snapLocalPosition - center;
       
        if (dot(snapLocalPositionToCenter, snapLocalPositionToCenter) > meshTriangleBuffer[i].triangleCALength2)
            continue;
           
        resultShadowTexture[id.xy] = i * 1.0 / indexCount;
        return;
        //float3 BAVec = pointB - pointA;
        //float3 CAVec = pointC - pointA;
       
        //float3 normalRaw = meshTriangleBuffer[i].normalRaw;
        //float area = meshTriangleBuffer[i].normalArea;

        ////use Barycentric Coordinates to determine is point inside trinagle
        //float3 na = cross(BAVec, snapLocalPosition - pointA);
        //float alpha = dot(na, normalRaw) / area;
        //if(alpha < 0 || alpha > 1)
        //    continue;
       
        //float3 nb = cross(snapLocalPosition - pointA, CAVec);
        //float beta = dot(nb, normalRaw) / area;
        //if (beta < 0 || beta > 1)
        //    continue;
       
        //float gamma = 1 - alpha - beta;
        //if (gamma < 0 || gamma > 1)
        //    continue;
       
        resultShadowTexture[id.xy] = 1;
        return;
   }
}

[numthreads(8,8,1)]
void CSMain2 (uint3 id : SV_DispatchThreadID) {
    if(id.x >= screenSize.x || id.y >= screenSize.y)
        return;
    
    resultShadowTexture[id.xy] = 0;
    
    float3 worldPosition = (gWorldPositionTexture[id.xy]).xyz;
    float3 pixelToCenter = worldPosition - objectCenter.xyz;
    
    float distanceToClosestPointObject = dot(pixelToCenter, globalLightDirection);
    float3 closetPointsToObject = worldPosition - (globalLightDirection * distanceToClosestPointObject);
    float3 closetPointToCenter = closetPointsToObject - objectCenter;

    if(abs(closetPointToCenter.x) > objectBound.x || abs(closetPointToCenter.y) > objectBound.y || abs(closetPointToCenter.z) > objectBound.z)
        return;
    
    resultShadowTexture[id.xy] = 0.2;
    
    float3 localPosition = mul(worldToObject, float4(worldPosition, 1)).xyz;
    
    for (int i = 0; i < indexCount; i += 3) {
        // Load index data
        uint3 triIndex = loadTriangleIndices(i); // id * 3[triangle vertices] * 4[bytes]
        
        // Load vertex data
        float3 pointA, pointB, pointC;
        float2 uvA, uvB, uvC;

        LoadVertexData(triIndex.x, pointA, uvA);
        LoadVertexData(triIndex.y, pointB, uvB);
        LoadVertexData(triIndex.z, pointC, uvC);
        
        float3 BAVec = pointB - pointA;
        float3 CAVec = pointC - pointA;
        
        float3 normalRaw = cross(BAVec, CAVec);
        
        // if caster's surface is align to light direction then ignore
        float dotNLocalLight = dot(-localLightDirection, normalRaw);
        if (dotNLocalLight < 0)
            continue;
        

        float area = dot(normalRaw, normalRaw);
        float normalLenght = sqrt(area);
        float3 normal = normalRaw / normalLenght;
        
        //float planeD = normal.x * pointA.x - normal.y * pointA.y - normal.z * pointA.z;
        
        float3 vec = localPosition - pointA;
        
        // if direction to closest point is opposite to received's surface normal 
        // or too close to receiver's point (consider as same point)
        // then ignore
        float dotVN = dot(vec, normal);
        float ln = (dotNLocalLight / normalLenght);
        float t = (dotVN) / ln;
        //float t = (dotVN) / dot(-localLightDirection, normal);
        if (t > CLOSEVALUE)
            continue;

        // progject receiver's point(pixel) to caster's surface
       float3 snapLocalPosition = localPosition + (localLightDirection * t);

        float3 center = (pointA + pointB + pointC) / 3;
        float3 triangleCA = center - pointA;
        
        float3 snapLocalPositionToCenter = snapLocalPosition - center;
        
        if (dot(snapLocalPositionToCenter, snapLocalPositionToCenter) > dot(triangleCA, triangleCA) + 0.5)
            continue;

        //use Barycentric Coordinates to determine is point inside trinagle
        float3 na = cross(BAVec, snapLocalPosition - pointA);
        float alpha = dot(na, normalRaw) / area;
        if(alpha < 0 || alpha > 1)
            continue;
        
        float3 nb = cross(snapLocalPosition - pointA, CAVec);
        float beta = dot(nb, normalRaw) / area;
        if (beta < 0 || beta > 1)
            continue;
        
        float gamma = 1 - alpha - beta;
        if (gamma < 0 || gamma > 1)
            continue;
        
        resultShadowTexture[id.xy] = 1;
        return;
    }
}


[numthreads(8,1,1)]
void CSPrepareMain (uint3 id : SV_DispatchThreadID) {
    if(id.x >= indexCount)
        return;
    
    meshTriangleBuffer[id.x].isIgnore = 1;

    // Load index data
    uint3 triIndex = loadTriangleIndices(id.x * 3); // id * 3[triangle vertices] * 4[bytes]

    // Load vertex data
    float3 pointA, pointB, pointC;
    float2 uvA, uvB, uvC;

    LoadVertexData(triIndex.x, pointA, uvA);
    LoadVertexData(triIndex.y, pointB, uvB);
    LoadVertexData(triIndex.z, pointC, uvC);

    float3 BAVec = pointB - pointA;
    float3 CAVec = pointC - pointA;
        
    float3 normalRaw = cross(BAVec, CAVec);
        
    // if caster's surface is align to light direction then ignore
    float dotNLocalLight = dot(-localLightDirection, normalRaw);
    if (dotNLocalLight < 0)
        return;

    float area = dot(normalRaw, normalRaw);
    float normalLength = sqrt(area);
    float3 normal = normalRaw / normalLength;
    float ln = (dotNLocalLight / normalLength);
    
    float3 center = (pointA + pointB + pointC) / 3;
    float3 triangleCA = center - pointA;

    meshTriangleBuffer[id.x].normalRaw = normalRaw;
    meshTriangleBuffer[id.x].normal = normal;
    meshTriangleBuffer[id.x].normalLength = normalLength;
    meshTriangleBuffer[id.x].normalArea = area;
    
    meshTriangleBuffer[id.x].pointA = pointA;
    meshTriangleBuffer[id.x].pointB = pointB;
    meshTriangleBuffer[id.x].pointC = pointC;
    
    meshTriangleBuffer[id.x].triangleCALength2 = dot(triangleCA, triangleCA);
    meshTriangleBuffer[id.x].ln = ln;
    meshTriangleBuffer[id.x].isIgnore = 0;
}